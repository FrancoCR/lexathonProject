.data
	gameObjective: 		.asciiz "	The object of the game is to find as many possible word combinations as you can given the letters you are provided with.\n"
	intro:			.asciiz "*********************************************************How To Play*******************************************************************\n"
	rulesOne:		.asciiz	"1. You have 60 seconds to input as many words as you can.\n"
	rulesTwo:		.asciiz "2. There is no penalty for wrong words.\n"
	rulesThree: 		.asciiz "3. Each word MUST have the key letter in the word, the key letter is located in the center of the grid.\n"
	rulesFour: 		.asciiz "4. Each word must have at least 4 different letters in it (no duplicate letters are allowed).\n"
	rulesFive:		.asciiz "5. When the 60 seconds is up the game is over or simply quit by entering 0.\n\n"
	beginGame: 		.asciiz "Enter 1 to begin the game or 0 to quit!"
	projectTextNewLine: 	.asciiz "\n"
	gameOver:		.asciiz "\n**************************************** GAME  OVER!! *************************************\n"
	scoreMessage:		.asciiz "\nTotal score: "
	missedWordsNumber:	.asciiz "Total number of missed words: "
	possibleWordsNumber:	.asciiz "\nNumber of possible words: "
	input: 			.space 9
	inputBad:		.asciiz "Invalid Entry, Please Try Again!\n"
	playAgainMessage:	.asciiz "\nWould you like to play again? Type '1' for Yes or '0' for No (Exit Program): "
	successMessage1: 	.asciiz "\nThe total number of correct words you enetered was: "
	duplicateMessage:	.asciiz "\nDuplicate word entered!\n"
	promptUser:		.asciiz "\nEnter your word or type '0' to Quit: "
	keyError:		.asciiz "\nYou didn's use the key letter! Try again...\n"
	gridPrint:		.asciiz "| "
	filler:			.asciiz "n "
	gridPrintRow:		.asciiz " ___ ___ ___\n"
	gridWord: 		.space 8
	
	startingKeyGen: .asciiz "\nStarting keyGen\n"

	newLine: .asciiz "\n"
	inKeyModValueOne: .asciiz "\nIn Mod Value One"
	inKeyModValueTwo: .asciiz "\nIn Mod Value Two"
	inKeyModValueThree: .asciiz "\nIn Mod Value Three"
	inKeyModValueFour: .asciiz "\nIn Mod Value Four"
	inKeyModValueFive: .asciiz "\nIn Mod Value Five"
	goodbye: .asciiz "\nTerminating"
	modValueIs: .asciiz "Mod value is "
	tempValueIs: .asciiz "Temp value is "
	resultsFromGetVowel: .asciiz "\nThe result from getVowel is: "

	## VOWELS
	vowelA: .byte 'a'
	vowelE: .byte 'e'
	vowelI: .byte 'i'
	vowelO: .byte 'o'
	vowelU: .byte 'u'
	
	startingStringGen: .asciiz "\nStarting StringGen\n"
	#goodbye: .asciiz "\n Terminating"
	#resultsFromGetVowel: .asciiz "\nThe result from getVowel is: "
	exitLoopStatement: .asciiz "Done with the loop -- Back in main"
	loopNumberStatement: .asciiz "This is loop number: "
	randomNumberStatement: .asciiz " The random int is: "
	letterStatement: .asciiz " The letter is: "
	newline: .asciiz "\n"
	getLetterStatement: .asciiz " In getLetter "
	inModValueOne: .asciiz " In modValue One"
	inModValueTwo: .asciiz " In modValue Two"
	inModValueThree: .asciiz " In modValue Three"


	## LETTERS ##
	letterA: .byte 'a'
	letterB: .byte 'b'
	letterC: .byte 'c'
	letterD: .byte 'd'
	letterE: .byte 'e'
	letterF: .byte 'f'
	letterG: .byte 'g'
	letterH: .byte 'h'
	letterI: .byte 'i'
	letterJ: .byte 'j'
	letterK: .byte 'k'
	letterL: .byte 'l'
	letterM: .byte 'm'
	letterN: .byte 'n'
	letterO: .byte 'o'
	letterP: .byte 'p'
	letterQ: .byte 'q'
	letterR: .byte 'r'
	letterS: .byte 's'
	letterT: .byte 't'
	letterU: .byte 'u'
	letterV: .byte 'v'
	letterW: .byte 'w'
	letterX: .byte 'x'
	letterY: .byte 'y'
	letterZ: .byte 'z'

	gridWordHold: 	.word 8

.text
startScreen:	

	li $v0, 4
     	la $a0, gameObjective
     	syscall   
    
     	la $a0, intro
     	syscall   
     	
     	la $a0, rulesOne
     	syscall   
     	
     	la $a0, rulesTwo
     	syscall   
     	
     	la $a0, rulesThree
     	syscall   
     	
     	la $a0, rulesFour
     	syscall   
     	
     	la $a0, rulesFive
     	syscall
     	
     	la $a0, projectTextNewLine
     	syscall  
     	
     	la $a0, beginGame
     	syscall
     	
     	li $v0, 5
     	syscall
     	
     	move $t1, $v0
     	blt $t1, 1, gameEnd
     	bgt $t1, 1, badInput
     	jal letterGen
     	
printGameGrid:
	move $t5, $zero
	
	li $v0, 4
	la $a0, gridPrintRow
     	syscall
	
     	la $a0, gridPrint
     	syscall   
     				
	li $v0, 11
     	lb $a0, gridWord($t5)
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
   	li $v0, 11
     	lb $a0, gridWord($t5)
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
	
     	li $v0, 11
     	lb $a0, gridWord($t5)
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
     	la $a0, projectTextNewLine
     	syscall
     	
     	la $a0, gridPrintRow
     	syscall
     	
     	la $a0, gridPrint
     	syscall   
     	
     	li $v0, 11
     	lb $a0, gridWord($t5)
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
    #######key letter######
    j keyGenerator
 printKeyLetter:
     	li $v0, 11
     	lb $a0, gridWord($t5)		
     	syscall
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
printGameGridHalf:
   	li $v0, 11
     	lb $a0, gridWord($t5)		
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
     	la $a0, projectTextNewLine
     	syscall
     	
     	la $a0, gridPrintRow
     	syscall
     	
     	la $a0, gridPrint
     	syscall   
     	
   	li $v0, 11
     	lb $a0, gridWord($t5)		
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
   	li $v0, 11
     	lb $a0, gridWord($t5)		
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
   	li $v0, 11
     	lb $a0, gridWord($t5)		
     	syscall
     	
     	addi $t5, $t5, 1
     	
	li $v0, 4
     	la $a0, gridPrint
     	syscall
     	
     	la $a0, projectTextNewLine
     	syscall
     	
     	la $a0, gridPrintRow
     	syscall
     	
     	li $v0, 10
	syscall
	
	move $t5, $zero#sets array back at zero
	
badInput:
	
	li $v0, 4
	la $a0, inputBad
	syscall
	
	j startScreen
	
gameEnd:

	li $v0, 4
	la $a0, scoreMessage

	li $v0, 10
	syscall
keyGenerator:
	#li $v0, 4
	#la $a0, startingKeyGen #Prints "Starting keyGen"
	#syscall

	li   $v0, 41       	# get a random int
	syscall

	divu $t0, $a0, 5   	# mod it by 5 so we can generate a vowel with that vowel
	mfhi $v0		# Get the remainder value
	addi $v0, $v0, 1	# add 1 to modValue to handle case where the div operation results in 0
	move $s0, $v0 		# move the mod value to $s0

	#li $v0, 4
	#la $a0, modValueIs 	# Prints statement "The mod value is "
	#syscall

	move $a0, $s0 		# move the modValue to $a0
	#li $v0, 1 		# print the mod value, this should be 0, 1, 2, 3 or 4
	#syscall

	jal getVowel 		# Call the function to return 1 vowel

	li $v0, 4
	la $a0, resultsFromGetVowel # Prints "The results from getVowel are : "
	syscall

	move $s7, $v1
	j printKeyLetter

	#li $v0, 11
	#la $a0, ($v1) # Actually prints the result from getVowel, which should be a character
	#syscall

#	li $v0, 4
#	la $a0, goodbye # Print "Terminating"
#	syscall

#	li $v0, 10 # Terminate program
#	syscall

keyModValueOne:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, vowelA  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

keyModValueTwo:
	#li $v0, 4
	#la $a0, inModValueTwo #Log Statement
	#syscall

	la $a0, vowelE  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

keyModValueThree:
	#li $v0, 4
	#la $a0, inModValueThree #Log Statement
	#syscall

	la $a0, vowelI  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

keyModValueFour:
	#li $v0, 4
	#la $a0, inModValueFour #Log Statement
	#syscall

	la $a0, vowelO  # Get the address
	lb $v1, 0($a0)  # Get the value at that address

	jr $ra

keyModValueFive:
	#li $v0, 4
	#la $a0, inModValueFive #Log Statement
	#syscall

	la $a0, vowelU  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

getVowel:
	#a0 holds the mod value, which is 1, 2, 3, 4 or 5 to be mapped to a variable

	beq $a0, 1 keyModValueOne #branch if $s0 == 1
	beq $a0, 2 keyModValueTwo #branch if $s0 == 2
	beq $a0, 3 keyModValueThree #branch if $s0 == 3
	beq $a0, 4 keyModValueFour #branch if $s0 == 4
	beq $a0, 5 keyModValueFive #branch if $s0 == 5

	jr $ra

letterGen:
	
	
	li $v0, 4
	la $a0, startingStringGen
	syscall

  	#t0 must be set to zero each time because we use a for loop with max value of zero in "loop"
  	#then we call the loop function 8 times. Obviously not the best way to do it, but it works.

  	#I think we should have another variable here, $t1, which we increment by four before calling loop each time
  	#That way, we can use that variable as the increasing offset for a word address to add bytes to a word?

  	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop
	add $t0, $0, $0 # Set $t0 to zero. This will be our counter
	jal loop

	

loop:
        addi $sp, $sp, -12   # make room on the stack
   	sw  $ra, -8($sp)     # store the address

   	bgt $t0,0, exit # If $t0 is greater than 2, branch to exit
    	addi $t0,$t0,1 # Add one to the value of $t0

    	#li $v0, 4
    	#la $a0, loopNumberStatement # Prints "This is loop number :
    	#syscall

    	#move $a0, $t0
    	#li $v0, 1 		# Prints the actual loop number
    	#syscall

    ## Perform work here ##

   	li   $v0, 41       	# get a random integer
	syscall

	divu $t2, $a0, 26  	# mod the value in $a0 by 26 and store in $t2 so we can generate a letter number
	mfhi $v0		# Get the remainder value
	addi $v0, $v0, 1	# add 1 to modValue to make numbers match those of the alphabet
	move $s0, $v0 		# move the mod value to $s0 to use elsewhere

	#li $v0, 4
	#la $a0, randomNumberStatement # Print "The random number is: "
	#syscall

	move $a0, $s0
	li $v0, 1	# Print the actual random number
	syscall

	move $a0, $s0   # Move the random int to $a0 to pass to the getLetter function
	jal getLetter

	#li $v0, 4
	#la $a0, letterStatement   #Prints "The letter is: "
	#syscall

	move $t7, $v1
	sb $t7, gridWordHold($t6)
	addi $t6, $t6, 1
	
	
	
	#li $v0, 4
	#la $a0, gridWord
	#syscall 

	#li $v0, 11
	#move $a0, $v1 # Actually prints the result from getLetter, which should be a letter of the alphabet
	#syscall

	#li $v0, 4
    	#la $a0, newline 	# Prints a new line
    	#syscall
    	
	beq $t6, 7, printGameGrid
	
    	j loop

exit:
	lw  $ra, 4($sp) # Do not change this or it will break
	jr $ra # return us to the caller, which brings us back to main

getLetter:
	#a0 holds the mod value, which should be 1 through 26 to be mapped to a letter of the alphabet

	beq $a0, 1 modValueOne #branch if $s0 == 1
	beq $a0, 2 modValueTwo #branch if $s0 == 2
	beq $a0, 3 modValueThree #branch if $s0 == 3
	beq $a0, 4 modValueFour #branch if $s0 == 4
	beq $a0, 5 modValueFive #branch if $s0 == 5
	beq $a0, 6 modValueSix #branch if $s0 == 6
	beq $a0, 7 modValueSeven #branch if $s0 == 7
	beq $a0, 8 modValueEight #branch if $s0 == 8
	beq $a0, 9 modValueNine #branch if $s0 == 9
	beq $a0, 10 modValueTen #branch if $s0 == 10
	beq $a0, 11 modValueEleven #branch if $s0 == 11
	beq $a0, 12 modValueTwelve #branch if $s0 == 12
	beq $a0, 13 modValueThirteen #branch if $s0 == 13
	beq $a0, 14 modValueFourteen #branch if $s0 == 14
	beq $a0, 15 modValueFifteen #branch if $s0 == 15
	beq $a0, 16 modValueSixteen #branch if $s0 == 16
	beq $a0, 17 modValueSeventeen #branch if $s0 == 17
	beq $a0, 18 modValueEighteen #branch if $s0 == 18
	beq $a0, 19 modValueNineteen #branch if $s0 == 19
	beq $a0, 20 modValueTwenty #branch if $s0 == 20
	beq $a0, 21 modValueTwentyOne #branch if $s0 == 21
	beq $a0, 22 modValueTwentyTwo #branch if $s0 == 22
	beq $a0, 23 modValueTwentyThree #branch if $s0 == 23
	beq $a0, 24 modValueTwentyFour #branch if $s0 == 24
	beq $a0, 25 modValueTwentyFive #branch if $s0 == 25
	beq $a0, 26 modValueTwentySix #branch if $s0 == 26

	jr $ra

modValueOne:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterA  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwo:
	#li $v0, 4
	#la $a0, inModValueTwo #Log Statement
	#syscall

	la $a0, letterB  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueThree:
	#li $v0, 4
	#la $a0, inModValueThree #Log Statement
	#syscall

	la $a0, letterC  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueFour:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterD  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueFive:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterE  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueSix:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterF  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueSeven:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterG  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueEight:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterH  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueNine:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterI  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterJ  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueEleven:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterK  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwelve:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterL  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueThirteen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterM  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueFourteen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterN  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueFifteen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterO  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueSixteen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterP  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueSeventeen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterQ  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueEighteen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterR  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueNineteen:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterS  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwenty:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterT  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwentyOne:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterU  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwentyTwo:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterV  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwentyThree:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterW  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwentyFour:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterX  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra

modValueTwentyFive:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterY  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra


modValueTwentySix:
	#li $v0, 4
	#la $a0, inModValueOne #Log Statement
	#syscall

	la $a0, letterZ  # Get the address
	lb $v1, ($a0)  # Get the value at that address

	jr $ra
	
